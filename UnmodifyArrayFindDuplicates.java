package Sort;

import org.junit.Test;

public class UnmodifyArrayFindDuplicates {

	/**
	 * 在一个长度为n+1的数组里的所有数字都在1〜n的范围内，所以数组 中至少有一个数字是重复的。
	 * 请找出数组中任意一个重复的数字，但不能 修改输入的数组。
	 * 例如，如果输入长度为8的数组{3, 5, 4, 3, 2, 6, 7},那 么对应的输出是重复的数字2或者3。
	 */
	
	/**解法一：
	 * 由于题目要求不能修改输入的数 组，我们可以创建一个长度为n+1的辅助数组，
	 * 然后逐一把原数组的每个 数字复制到辅助数组。
	 * 如果原数组中被复制的数字是m,则把它复制到辅 助数组中下标为m的位置。
	 * 这样很容易就能发现哪个数字是重复的。由于 需要创建一个数组，该方案需要0(n)的辅助空间。
	 */
	@Test
	public void test1(){
		int[] a={3, 5, 4, 3, 2, 6, 7};
		int b[]=new int[8];
		for(int i=0;i<a.length;i++){
			if(b[a[i]]!=a[i]){
				b[a[i]]=a[i];
			}else{
				System.out.println(a[i]);
			}
		}
	}
	
	/**
	 * 接下来我们尝试避免使用〇(n)的辅助空间。为什么数组中会有重复的 数字？假如没有重复的数字，那么在从1〜n的范围里只有n个数字。
	 * 由于 数组里包含超过n个数字，所以一定包含了重复的数字。看起来在某范围 里数字的个数对解决这个问题很重要。
	 * 我们把从1〜n的数字从中间的数字m分为两部分，前面一半为1〜m 后面一半为m+1〜n。如果1〜m的数字的数目超过m，那么这一半的区间 里一定包含重复的数字；
	 * 否则，另一半m+l〜n的区间里一定包含重复的数 字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的 数字。
	 * 这个过程和二分查找算法很类似，只是多了一步统计区间里数字的 数目。
	 * 我们以长度为8的数组丨2, 3, 5, 4, 3, 2, 6, 7丨为例分析查找的过程。
	 * 根据 题目要求，这个长度为8的所有数字都在1〜7的范围内。中间的数字4把 1〜7的范围分为两段，一段是1〜4，另一段是5〜7。
	 * 接下来我们统计1〜 4这4个数字在数组中出现的次数，它们一共出现了 5次，因此这4个数字 中一定有重复的数字。
	 * 接下来我们再把1〜4的范围一分为二，一段是1、2两个数字，另一 段是3、4两个数字。
	 * 数字1或者2在数组中一共出现了两次。我们再统计 数字3或者4在数组中出现的次数，它们一共出现了三次。
	 * 这意味着3、4 两个数字中一定有一个重复了。我们再分别统计这两个数字在数组中出现 的次数。接着我们发现数字3出现了两次，是一个重复的数字。

	 */
//	@Test
//	public void test2(){
//		int a[]={3, 5, 4, 3, 2, 6, 7};
//		
//	}
//	
//	public int patition(int[] a,int low ,int high){
//		if(low<high){
//			int mid=(low+high)/2;
//			
//			patition(a, low, mid);
//			patition(a, mid+1, high);
//		}
//	}
	
	public static void main(String[] args){
		
	}

}
